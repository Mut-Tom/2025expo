<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <!-- ãƒšãƒ¼ã‚¸ã®ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç„¡åŠ¹åŒ– -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>ã‚¯ãƒªãƒƒã‚¯å¡—ã‚Šã¤ã¶ã—ãƒãƒƒãƒ—</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html,body { height: 100%; }
    .touch-none { touch-action: none; } /* è¦ç´ å˜ä½ã§ãƒ”ãƒ³ãƒç„¡åŠ¹åŒ–ï¼†ç‹¬è‡ªãƒ‘ãƒ³ */
    kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;background:#f5f5f5;border:1px solid #ddd;border-bottom-width:2px;padding:2px 6px;border-radius:6px;font-size:12px;}
    .btn-compact{ padding:6px 10px; border-radius:12px; border:1px solid #e5e7eb; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.04); }
    .icon-label{ display:none; }
    @media (min-width: 1024px){
      .icon-label{ display:inline; }
      .icon-only{ display:none; }
    }
    .zoom-input{ width:72px; text-align:right; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    const DEFAULT_IMAGE = "map.png"; // åŒéšå±¤ã« map.png ãŒã‚ã‚Œã°è‡ªå‹•è¡¨ç¤º

    const PALETTE_GROUPS = {
      Inochi: ["#e60012", "#0068b7", "#ffffff"],
      Umi:    ["#9b89c6", "#0095b6", "#82cddd", "#8fc31f"],
      Noyama: ["#c5d200", "#fff100", "#0072bc"],
      Hikari: ["#f39800", "#e60012", "#ffd900"],
    };

    const LS = {
      get(key, def=null){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : def; }catch{ return def; } },
      set(key, val){ localStorage.setItem(key, JSON.stringify(val)); },
      del(key){ localStorage.removeItem(key); }
    };

    const hashStr = (s) => { let h = 5381; for (let i=0;i<s.length;i++) h = ((h<<5)+h) + s.charCodeAt(i); return (h>>>0).toString(16); };

    const LS_COLOR      = "mf_color";
    const LS_RECENT     = "mf_recent";
    const LS_ACTIONS_NS = "mf_actions:";

    function App() {
      const canvasRef = useRef(null);
      const overlayRef = useRef(null);
      const fileInputRef = useRef(null);
      const viewportRef = useRef(null);

      const [img, setImg] = useState(null);
      const [imageKey, setImageKey] = useState(null);
      const [zoom, setZoom] = useState(1);
      const [zoomInput, setZoomInput] = useState("100");

      const [color, setColor] = useState(LS.get(LS_COLOR, "#e60012"));
      const [recentColors, setRecentColors] = useState(LS.get(LS_RECENT, []));
      const [tolerance, setTolerance] = useState(28);
      const [contiguous, setContiguous] = useState(true);
      const [mode, setMode] = useState("fill"); // "fill" | "eyedropper"
      const [undoStack, setUndoStack] = useState([]);
      const [redoStack, setRedoStack] = useState([]);
      const [canvasSize, setCanvasSize] = useState({ w: 0, h: 0 });

      const [isPanning, setIsPanning] = useState(false);
      const panStateRef = useRef({ startX:0, startY:0, scrollL:0, scrollT:0, moved:false, pointerId:null });
      const suppressClickRef = useRef(false);

      // ===== ãƒšãƒ¼ã‚¸å´ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç„¡åŠ¹åŒ– =====
      useEffect(() => {
        const stopWheelZoom = (e) => { if (e.ctrlKey || e.metaKey) e.preventDefault(); };
        const stopGesture = (e) => { e.preventDefault(); }; // iOS Safari
        document.addEventListener('wheel', stopWheelZoom, { passive: false });
        document.addEventListener('gesturestart', stopGesture, { passive: false });
        document.addEventListener('gesturechange', stopGesture, { passive: false });
        document.addEventListener('gestureend', stopGesture, { passive: false });
        return () => {
          document.removeEventListener('wheel', stopWheelZoom);
          document.removeEventListener('gesturestart', stopGesture);
          document.removeEventListener('gesturechange', stopGesture);
          document.removeEventListener('gestureend', stopGesture);
        };
      }, []);

      // ===== ã‚ºãƒ¼ãƒ  =====
      const clampZoom = (z) => Math.min(3, Math.max(0.5, +z.toFixed(3)));
      const updateZoom = (nextZoom, anchorClient=null) => {
        const nz = clampZoom(nextZoom);
        const vp = viewportRef.current;
        const cnv = canvasRef.current;
        if (!vp || !cnv) { setZoom(nz); return; }

        const vpRect = vp.getBoundingClientRect();
        const cx = anchorClient ? (anchorClient.x - vpRect.left) : vpRect.width/2;
        const cy = anchorClient ? (anchorClient.y - vpRect.top)  : vpRect.height/2;

        const oldRect = cnv.getBoundingClientRect();
        const oldW = oldRect.width, oldH = oldRect.height;
        const contentX = vp.scrollLeft + cx;
        const contentY = vp.scrollTop  + cy;

        setZoom(nz);
        applyCanvasCssSize(img);

        const newRect = cnv.getBoundingClientRect();
        const scaleX = newRect.width / (oldW || 1);
        const scaleY = newRect.height / (oldH || 1);

        vp.scrollLeft = contentX * scaleX - cx;
        vp.scrollTop  = contentY * scaleY - cy;
      };

      // åˆæœŸç”»åƒãƒ­ãƒ¼ãƒ‰ï¼ˆ?img= ã‚¯ã‚¨ãƒªå„ªå…ˆ â†’ ç„¡ã‘ã‚Œã° DEFAULT_IMAGEï¼‰
      const getImgFromQuery = () => {
        const p = new URLSearchParams(location.search);
        const v = p.get("img");
        return v && v.trim() ? v.trim() : null;
      };
      useEffect(() => {
        const first = getImgFromQuery() || DEFAULT_IMAGE;
        autoLoadImage(first).catch(() => console.warn("è‡ªå‹•èª­ã¿è¾¼ã¿ç”¨ã®ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:", first));
      }, []);

      // ç”»åƒ D&D
      useEffect(() => {
        const onDrop = (e) => { e.preventDefault(); const f = e.dataTransfer?.files?.[0]; if (f) loadFile(f); };
        const onDrag = (e) => e.preventDefault();
        window.addEventListener("drop", onDrop);
        window.addEventListener("dragover", onDrag);
        return () => { window.removeEventListener("drop", onDrop); window.removeEventListener("dragover", onDrag); };
      }, []);

      // ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
      useEffect(() => {
        const isEditable = (el) => {
          if (!el) return false;
          const tag = el.tagName?.toLowerCase();
          return tag === "input" || tag === "textarea" || tag === "select" || el.isContentEditable;
        };
        const clampTol = (v) => Math.max(0, Math.min(128, v));
        const onKeyDown = (e) => {
          if (isEditable(document.activeElement)) return;
          const ctrl = e.ctrlKey || e.metaKey;
          const shift = e.shiftKey;
          const key = e.key;

          if (ctrl && key.toLowerCase() === "z" && !shift) { e.preventDefault(); undo(); return; }
          if ((ctrl && key.toLowerCase() === "y") || (ctrl && key.toLowerCase() === "z" && shift)) { e.preventDefault(); redo(); return; }

          if (!ctrl && !shift && key.toLowerCase() === "f") { setMode("fill"); return; }
          if (!ctrl && !shift && key.toLowerCase() === "i") { setMode("eyedropper"); return; }
          if (!ctrl && !shift && key.toLowerCase() === "b") { setMode(m => m==="fill" ? "eyedropper" : "fill"); return; }

          if (!ctrl && !shift && key.toLowerCase() === "s") { e.preventDefault(); savePng(); return; }
          if (!ctrl && !shift && key.toLowerCase() === "o") { e.preventDefault(); handleOpen(); return; }
          if (!ctrl && !shift && key.toLowerCase() === "r") { e.preventDefault(); clearToOriginal(); return; }

          if (!ctrl && !shift && key.toLowerCase() === "g") { setContiguous(v => !v); return; }

          if (key === "[" || key === "-") { setTolerance(v => clampTol(v - 4)); return; }
          if (key === "]" || key === "=" || key === "+") { setTolerance(v => clampTol(v + 4)); return; }
        };
        window.addEventListener("keydown", onKeyDown, { passive: false });
        return () => window.removeEventListener("keydown", onKeyDown);
      }, [undoStack, redoStack]);

      // è‰²ã®ä¿å­˜ï¼†æœ€è¿‘è‰²
      useEffect(() => {
        LS.set(LS_COLOR, color);
        setRecentColors((prev) => {
          const next = [color, ...prev.filter(c => c !== color)].slice(0, 12);
          LS.set(LS_RECENT, next);
          return next;
        });
      }, [color]);

      // zoom â†’ å…¥åŠ›æ¬„åæ˜ 
      useEffect(() => {
        setZoomInput(String(Math.round(zoom * 100)));
      }, [zoom]);

      // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆCSSæ‹¡å¤§ã®ã¿ï¼‰
      const getMaxCanvasCssWidth = () => {
        const outerPadding = 24 * 2;
        const cardPadding  = 16 * 2;
        const gap = 24;
        const isDesktop = window.matchMedia("(min-width: 1024px)").matches;
        const viewport = Math.min(window.innerWidth, 1536);
        if (isDesktop) {
          return Math.max(240, viewport - 360 - gap - outerPadding - cardPadding);
        } else {
          return Math.max(240, viewport - outerPadding - cardPadding);
        }
      };

      const applyCanvasCssSize = (imageOrNull) => {
        const canvas  = canvasRef.current;
        const overlay = overlayRef.current;
        if (!canvas) return;

        const imgW = imageOrNull?.width  ?? canvas.width;
        const imgH = imageOrNull?.height ?? canvas.height;

        const maxCssW = getMaxCanvasCssWidth();
        const baseRatio = Math.min(1, maxCssW / imgW);
        const ratio = baseRatio * zoom;

        const cssW = Math.round(imgW * ratio);
        const cssH = Math.round(imgH * ratio);
        canvas.style.width  = cssW + "px";
        canvas.style.height = cssH + "px";
        if (overlay) {
          overlay.style.width  = cssW + "px";
          overlay.style.height = cssH + "px";
        }
      };

      const centerViewport = () => {
        const vp = viewportRef.current;
        if (!vp) return;
        vp.scrollLeft = Math.max(0, (vp.scrollWidth  - vp.clientWidth)  / 2);
        vp.scrollTop  = Math.max(0, (vp.scrollHeight - vp.clientHeight) / 2);
      };

      // ç”»åƒ I/O
      const loadFile = (file) => {
        const reader = new FileReader();
        reader.onload = () => {
          const image = new Image();
          image.onload = () => afterImageLoaded(image, file.name || "file");
          image.src = reader.result;
        };
        reader.readAsDataURL(file);
      };
      const autoLoadImage = (url) => new Promise((resolve, reject) => {
        if (!url) return reject();
        const image = new Image();
        image.crossOrigin = "anonymous";
        image.onload = () => { afterImageLoaded(image, url); resolve(); };
        image.onerror = reject;
        image.src = url;
      });

      const afterImageLoaded = (image, srcHint) => {
        setImg(image);

        const canvas  = canvasRef.current;
        const overlay = overlayRef.current;
        canvas.width = image.width;
        canvas.height = image.height;
        if (overlay) { overlay.width = image.width; overlay.height = image.height; }
        setCanvasSize({ w: image.width, h: image.height });

        drawImage(image);
        setUndoStack([]); setRedoStack([]);

        const keySeed = (srcHint || image.src) + `@${image.width}x${image.height}`;
        const key = LS_ACTIONS_NS + hashStr(keySeed);
        setImageKey(key);

        applyCanvasCssSize(image);
        centerViewport();

        const saved = LS.get(key, []);
        if (saved?.length) replayActions(saved);
      };

      const drawImage = (image) => {
        const c = canvasRef.current, ctx = c.getContext("2d");
        ctx.clearRect(0,0,c.width,c.height); ctx.imageSmoothingEnabled = true;
        ctx.drawImage(image, 0,0, image.width,image.height, 0,0, c.width,c.height);
      };

      // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚º
      useEffect(() => {
        const onResize = () => { applyCanvasCssSize(img); centerViewport(); };
        window.addEventListener("resize", onResize);
        return () => window.removeEventListener("resize", onResize);
      }, [img, zoom]);

      // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
      const getImageXY = (evt) => {
        const rect = evt.target.getBoundingClientRect();
        const x = Math.floor(((evt.clientX - rect.left) * (canvasSize.w / rect.width)));
        const y = Math.floor(((evt.clientY - rect.top) * (canvasSize.h / rect.height)));
        return { x, y };
      };
      const getPixel = (data, idx) => [data[idx], data[idx+1], data[idx+2], data[idx+3]];
      const colorDist = (a,b) => { const dr=a[0]-b[0], dg=a[1]-b[1], db=a[2]-b[2]; return Math.sqrt(dr*dr+dg*dg+db*db); };
      const hexToRgb = (hex) => { const m=/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex); return [parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)]; };
      const match = (pix,target,tol) => colorDist(pix,target) <= tol;

      // ãƒ•ã‚£ãƒ«
      const floodFillContiguous = (data,w,h,sx,sy,target,fill,tol) => {
        const visited = new Uint8Array(w*h), q=[[sx,sy]];
        while(q.length){
          const [x,y]=q.pop(); if(x<0||y<0||x>=w||y>=h) continue;
          const idx=(y*w+x)*4; if(visited[y*w+x]) continue;
          const pix=[data[idx],data[idx+1],data[idx+2]]; if(!match(pix,target,tol)) continue;
          visited[y*w+x]=1; data[idx]=fill[0]; data[idx+1]=fill[1]; data[idx+2]=fill[2]; data[idx+3]=255;
          q.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
        }
      };
      const floodFillGlobal = (data,w,h,target,fill,tol) => {
        for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ const idx=(y*w+x)*4;
          const pix=[data[idx],data[idx+1],data[idx+2]]; if(match(pix,target,tol)){ data[idx]=fill[0]; data[idx+1]=fill[1]; data[idx+2]=fill[2]; data[idx+3]=255; }
        }}
      };

      const applyFillAt = ({x, y, colorHex, tol, contig}) => {
        if (!img) return;
        const c = canvasRef.current;
        const ctx = c.getContext("2d", { willReadFrequently: true });
        const imgData = ctx.getImageData(0,0,c.width,c.height);
        const data = imgData.data;
        const idx0 = (y * c.width + x) * 4;

        const target = [data[idx0], data[idx0+1], data[idx0+2]];
        const fillCol = hexToRgb(colorHex);
        if (colorDist(target, fillCol) <= 1) return;

        if (contig) floodFillContiguous(data, c.width, c.height, x, y, target, fillCol, tol);
        else        floodFillGlobal    (data, c.width, c.height,      target, fillCol, tol);

        ctx.putImageData(imgData, 0, 0);
      };

      const replayActions = (actions) => {
        if (!actions || !actions.length) return;
        const c = canvasRef.current;
        const ctx = c.getContext("2d", { willReadFrequently: true });
        let imgData = ctx.getImageData(0,0,c.width,c.height);
        let data = imgData.data;
        for (const a of actions) {
          const {x,y,colorHex,tol,contig} = a;
          const idx0 = (y * c.width + x) * 4;
          const target = [data[idx0], data[idx0+1], data[idx0+2]];
          const fillCol = hexToRgb(colorHex);
          if (colorDist(target, fillCol) <= 1) continue;
          if (contig) {
            ctx.putImageData(imgData, 0, 0);
            applyFillAt({x,y,colorHex,tol,contig});
            imgData = ctx.getImageData(0,0,c.width,c.height);
            data = imgData.data;
          } else {
            floodFillGlobal(data, c.width, c.height, target, fillCol, tol);
          }
        }
        ctx.putImageData(imgData, 0, 0);
      };

      // ã‚¯ãƒªãƒƒã‚¯ï¼ˆã‚¹ãƒã‚¤ãƒˆ/å¡—ã‚Šï¼‰
      const handleCanvasClick = (e) => {
        if (suppressClickRef.current) { suppressClickRef.current = false; return; }
        if (!img) return;

        const { x, y } = getImageXY(e);
        const c = canvasRef.current, ctx = c.getContext("2d", { willReadFrequently: true });
        const imgData = ctx.getImageData(0,0,c.width,c.height), data = imgData.data;
        const idx0 = (y * c.width + x) * 4;

        if (mode === "eyedropper") {
          const [r,g,b] = getPixel(data, idx0);
          setColor("#" + [r,g,b].map(v=>v.toString(16).padStart(2,"0")).join(""));
          setMode("fill");
          return;
        }

        pushUndo();

        const action = { x, y, colorHex: color, tol: tolerance, contig: contiguous };
        applyFillAt(action);

        if (imageKey) {
          try {
            const prev = LS.get(imageKey, []);
            const next = [...prev, action];
            LS.set(imageKey, next);
          } catch (err) {
            console.warn("localStorage ä¿å­˜ã«å¤±æ•—ï¼š", err);
            alert(`ä¿å­˜å®¹é‡ãŒã„ã£ã±ã„ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å³ãƒ‘ãƒãƒ«ã®ã€Œã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã€ã§\nãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ã‹ã‚‰ã€å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¦ãã ã•ã„ã€‚`);
          }
        }
      };

      const canPan = () => {
        const vp = viewportRef.current;
        if (!vp) return false;
        return vp.scrollWidth > vp.clientWidth || vp.scrollHeight > vp.clientHeight || zoom > 1;
      };

      // ===== ãƒ‘ãƒ³ï¼ˆãƒ”ãƒ³ãƒæ’é™¤ãƒ»1æœ¬æŒ‡ï¼‰===== ã‚¯ãƒªãƒƒã‚¯ã‚’æ®ºã•ãªã„ã‚ˆã†ã«ä¿®æ­£
      const onPointerDown = (e) => {
        // ãƒ‘ãƒ³ã§ãã‚‹æ™‚ã ã‘ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æŠ‘æ­¢ï¼ˆã‚¯ãƒªãƒƒã‚¯ã¯é€šã™ï¼‰
        if (!canPan()) return;
        e.preventDefault();
        const vp = viewportRef.current;
        panStateRef.current = {
          startX: e.clientX,
          startY: e.clientY,
          scrollL: vp.scrollLeft,
          scrollT: vp.scrollTop,
          moved: false,
          pointerId: e.pointerId
        };
        e.currentTarget.setPointerCapture(e.pointerId);
        setIsPanning(true);
      };

      const onPointerMove = (e) => {
        if (!isPanning) return; // ãƒ‘ãƒ³ä¸­ã ã‘æŠ‘æ­¢
        e.preventDefault();
        const vp = viewportRef.current;
        const st = panStateRef.current;
        const dx = e.clientX - st.startX;
        const dy = e.clientY - st.startY;
        if (Math.abs(dx) + Math.abs(dy) > 3) st.moved = true;
        vp.scrollLeft = st.scrollL - dx;
        vp.scrollTop  = st.scrollT - dy;
      };

      const endPan = (e) => {
        if (!isPanning) return;
        setIsPanning(false);
        if (panStateRef.current.moved) suppressClickRef.current = true;
      };

      // ===== PCå‘ã‘ï¼šCtrl/âŒ˜ + ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚¢ãƒ—ãƒªå†…ã‚ºãƒ¼ãƒ ï¼ˆãƒšãƒ¼ã‚¸ã‚ºãƒ¼ãƒ ã¯æŠ‘æ­¢ï¼‰ =====
      const onWheel = (e) => {
        if (!e.ctrlKey && !e.metaKey) return;
        e.preventDefault();
        const factor = Math.exp(-e.deltaY * 0.0015);
        updateZoom(zoom * factor, { x: e.clientX, y: e.clientY });
      };

      // Undo/Redo
      const pushUndo = () => {
        const c = canvasRef.current, ctx = c.getContext("2d");
        const snap = ctx.getImageData(0,0,c.width,c.height);
        setUndoStack(prev => { const next=[...prev, snap]; if(next.length>20) next.shift(); return next; });
        setRedoStack([]);
      };
      const undo = () => {
        const c = canvasRef.current, ctx = c.getContext("2d");
        setUndoStack(prev => { if(!prev.length) return prev;
          setRedoStack(r => [...r, ctx.getImageData(0,0,c.width,c.height)]);
          const last = prev[prev.length-1]; ctx.putImageData(last,0,0);
          if (imageKey) {
            const log = LS.get(imageKey, []);
            if (log.length) { log.pop(); LS.set(imageKey, log); }
          }
          return prev.slice(0,-1);
        });
      };
      const redo = () => {
        const c = canvasRef.current, ctx = c.getContext("2d");
        setRedoStack(prev => { if(!prev.length) return prev;
          setUndoStack(u => [...u, ctx.getImageData(0,0,c.width,c.height)]);
          const last = prev[prev.length-1]; ctx.putImageData(last,0,0);
          return prev.slice(0,-1);
        });
      };

      const handleOpen = () => fileInputRef.current?.click();
      const handleFile = (e) => { const f = e.target.files?.[0]; if (f) loadFile(f); };
      const savePng = () => { const a=document.createElement("a"); a.download="colored-map.png"; a.href=canvasRef.current.toDataURL("image/png"); a.click(); };

      const clearToOriginal = () => {
        if (!img) return;
        drawImage(img);
        setUndoStack([]); setRedoStack([]);
        if (imageKey) LS.del(imageKey);
      };

      const exportState = () => {
        if (!imageKey) return;
        const data = {
          imageKey,
          actions: LS.get(imageKey, []),
          meta: { ts: Date.now(), tolerance, contiguous }
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.download = `mapfill_${imageKey}.json`;
        a.href = URL.createObjectURL(blob);
        a.click();
      };
      const importState = (file) => {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const data = JSON.parse(reader.result);
            if (!data || !Array.isArray(data.actions)) throw new Error("invalid json");
            LS.set(imageKey, data.actions);
            drawImage(img);
            replayActions(data.actions);
          } catch (e) {
            alert("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚JSONå½¢å¼ã‚’ã”ç¢ºèªãã ã•ã„ã€‚");
          }
        };
        reader.readAsText(file);
      };

      // ====== æ‹¡å¤§ç‡å…¥åŠ›ï¼šè‡ªç”±å…¥åŠ›ï¼†é©ç”¨ãƒœã‚¿ãƒ³ï¼†Enterå¯¾å¿œ ======
      const applyZoomInput = () => {
        let raw = (zoomInput ?? "").toString().trim().replace(/\s+/g,"");
        if (raw.endsWith("%")) raw = raw.slice(0,-1);
        let val = parseInt(raw,10);
        if (isNaN(val)) { setZoomInput(String(Math.round(zoom*100))); return; }
        val = Math.max(50, Math.min(300, val));
        setZoomInput(String(val));
        updateZoom(val/100); // ç”»é¢ä¸­å¿ƒåŸºæº–
      };
      const onZoomInputKey = (e) => {
        if (e.key === "Enter") { e.preventDefault(); applyZoomInput(); }
        else if (e.key === "Escape") { setZoomInput(String(Math.round(zoom*100))); e.currentTarget.blur(); }
        else if (e.key === "ArrowUp") { e.preventDefault(); const v = Math.min(300, (parseInt(zoomInput||"0",10)||0) + 10); setZoomInput(String(v)); }
        else if (e.key === "ArrowDown") { e.preventDefault(); const v = Math.max(50, (parseInt(zoomInput||"0",10)||0) - 10); setZoomInput(String(v)); }
      };

      return (
        <div className="min-h-screen w-full">
          <header className="sticky top-0 z-20 border-b bg-white/90 backdrop-blur">
            <div className="mx-auto max-w-screen-2xl px-4 py-2 flex items-center gap-2 flex-wrap">
              <div className="text-lg font-bold">ã‚¯ãƒªãƒƒã‚¯ã§å¡—ã‚Šã¤ã¶ã›ã‚‹ãƒãƒƒãƒ—</div>
              <div className="ml-auto flex items-center gap-1 flex-wrap">
                <button onClick={handleOpen} className="btn-compact" title="ç”»åƒã‚’é–‹ã (O)">
                  <span className="icon-only" aria-hidden>ğŸ“‚</span><span className="icon-label"> ç”»åƒã‚’é–‹ã <span className="text-xs text-gray-500">(O)</span></span>
                </button>
                <button onClick={savePng} className="btn-compact" title="PNGä¿å­˜ (S)">
                  <span className="icon-only" aria-hidden>ğŸ’¾</span><span className="icon-label"> PNGä¿å­˜ <span className="text-xs text-gray-500">(S)</span></span>
                </button>
                <button onClick={undo} disabled={!undoStack.length} className="btn-compact" title="Undo (âŒ˜/Ctrl+Z)">
                  <span className="icon-only" aria-hidden>â†¶</span><span className="icon-label"> Undo <span className="text-xs text-gray-500">(âŒ˜/Ctrl+Z)</span></span>
                </button>
                <button onClick={redo} disabled={!redoStack.length} className="btn-compact" title="Redo (âŒ˜/Ctrl+Shift+Z / Y)">
                  <span className="icon-only" aria-hidden>â†·</span><span className="icon-label"> Redo <span className="text-xs text-gray-500">(âŒ˜/Ctrl+Shift+Z / Y)</span></span>
                </button>
                <button onClick={clearToOriginal} className="btn-compact" title="çŠ¶æ…‹ã‚¯ãƒªã‚¢ (R)">
                  <span className="icon-only" aria-hidden>â™»</span><span className="icon-label"> çŠ¶æ…‹ã‚¯ãƒªã‚¢ <span className="text-xs text-gray-500">(R)</span></span>
                </button>
              </div>
            </div>
          </header>

          <main className="mx-auto max-w-screen-2xl p-4 grid grid-cols-1 lg:grid-cols-[_1fr_360px] gap-6">
            <div className="rounded-2xl bg-white border shadow p-3">
              <div
                ref={viewportRef}
                className="relative overflow-auto rounded-xl text-center touch-none"
                style={{maxHeight: 'calc(100vh - 180px)'}}
                onPointerDown={onPointerDown}
                onPointerMove={onPointerMove}
                onPointerUp={endPan}
                onPointerCancel={endPan}
                onPointerLeave={endPan}
                onWheel={onWheel}
              >
                <div className="relative inline-block">
                  <canvas
                    ref={canvasRef}
                    className={"rounded-xl shadow border select-none touch-none " + (canPan() ? (isPanning ? "cursor-grabbing" : "cursor-grab") : "cursor-crosshair")}
                    onClick={handleCanvasClick}
                  />
                  <canvas ref={overlayRef} className="absolute inset-0 pointer-events-none rounded-xl" />
                </div>

                {/* å›ºå®šHUDï¼ˆè‡ªç”±å…¥åŠ›ï¼‹é©ç”¨ãƒœã‚¿ãƒ³ã®ã¿ï¼‰ */}
                <div className="sticky bottom-2 left-0 right-0 flex justify-center pointer-events-none">
                  <div className="pointer-events-auto inline-flex items-center gap-2 px-3 py-1.5 rounded-full border bg-white/90 shadow text-sm">
                    <form
                      onSubmit={(e) => { e.preventDefault(); applyZoomInput(); }}
                      className="flex items-center gap-1"
                    >
                      <span className="text-gray-600">Zoom</span>
                      <input
                        className="zoom-input px-2 py-0.5 border rounded"
                        value={zoomInput}
                        onChange={(e)=> setZoomInput(e.target.value)}  // %ä»˜ãã‚‚ä¸€æ—¦è¨±å¯
                        onKeyDown={onZoomInputKey}
                        onBlur={applyZoomInput}
                        inputMode="numeric"
                        aria-label="æ‹¡å¤§ç‡ã‚’ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆã§å…¥åŠ›"
                        placeholder="100"
                      />
                      <span>%</span>
                      <button type="submit" className="px-2 py-0.5 border rounded">é©ç”¨</button>
                    </form>
                  </div>
                </div>
              </div>
            </div>

            <aside className="rounded-2xl bg-white border shadow p-4 flex flex-col gap-5">
              <div className="text-xs text-gray-500">ä¿å­˜å…ˆ: localStorageï¼ˆç”»åƒã”ã¨ã«åˆ†é›¢ï¼‰ï¼ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³ã€<b>äºŒæœ¬æŒ‡ãƒ”ãƒ³ãƒã¯ç„¡åŠ¹</b>ãƒ»PCã¯ <b>Ctrl/âŒ˜+ãƒ›ã‚¤ãƒ¼ãƒ«</b> ã§ã‚ºãƒ¼ãƒ ï¼ˆHUDå›ºå®šï¼‰ã€‚</div>

              <div>
                <div className="text-sm font-semibold mb-1">ç¾åœ¨ã®è‰²</div>
                <input type="color" className="w-full h-10 rounded-lg border" value={color} onChange={(e)=>setColor(e.target.value)} />
              </div>

              <div>
                <div className="text-sm font-semibold mb-1">æœ€è¿‘ä½¿ã£ãŸè‰²</div>
                <div className="grid grid-cols-6 gap-2">
                  {recentColors.length === 0 ? (
                    <div className="text-xs text-gray-500 col-span-6">ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚è‰²ã‚’é¸ã‚“ã§å¡—ã‚‹ã¨ã“ã“ã«è²¯ã¾ã‚Šã¾ã™ã€‚</div>
                  ) : (
                    recentColors.map((p,idx)=>(
                      <button key={p+idx} onClick={()=>setColor(p)} className="h-9 rounded-lg border" style={{background:p}} aria-label={p} title={p}></button>
                    ))
                  )}
                </div>
              </div>

              {Object.entries(PALETTE_GROUPS).map(([label, list]) => (
                <div key={label}>
                  <div className="text-sm font-semibold mb-1">{label}</div>
                  <div className="grid grid-cols-6 gap-2">
                    {list.map((p,idx)=>(
                      <button key={p+idx} onClick={()=>setColor(p)} className="h-9 rounded-lg border" style={{background:p}} aria-label={p} title={p}></button>
                    ))}
                  </div>
                </div>
              ))}

              <div>
                <div className="text-sm font-semibold mb-1">è¨±å®¹å·®ï¼ˆè¼ªéƒ­ã®ã«ã˜ã¿å¯¾ç­–ï¼‰ <span className="text-xs text-gray-400">[ / ] ã¾ãŸã¯ - / =</span></div>
                <input type="range" min="0" max="128" value={tolerance} onChange={(e)=>setTolerance(parseInt(e.target.value))} className="w-full" />
                <div className="text-xs text-gray-600">ç¾åœ¨: {tolerance}</div>
              </div>

              <div>
                <label className="flex items-center gap-2 text-sm">
                  <input type="checkbox" checked={contiguous} onChange={(e)=>setContiguous(e.target.checked)} />
                  é€£çµã®ã¿ã‚’å¡—ã‚‹ï¼ˆON æ¨å¥¨ï¼‰ <span className="text-xs text-gray-400 ml-1">(G)</span>
                </label>
              </div>

              <div className="border-t pt-3 flex items-center gap-2">
                <button onClick={exportState} className="px-3 py-1.5 rounded-xl shadow bg-white hover:bg-gray-50 border text-sm">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <label className="px-3 py-1.5 rounded-xl shadow bg-white hover:bg-gray-50 border text-sm cursor-pointer">
                  ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                  <input type="file" accept="application/json" className="hidden" onChange={(e)=>{ const f=e.target.files?.[0]; if(f) importState(f); e.target.value=""; }} />
                </label>
                <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={handleFile} />
              </div>
            </aside>
          </main>

          <section className="mx-auto max-w-screen-2xl px-4 pb-4">
            <div className="rounded-2xl bg-white border shadow p-4">
              <h2 className="font-semibold mb-2">ä½¿ã„æ–¹</h2>
              <ul className="list-disc ml-5 space-y-1 text-sm">
                <li><b>ã‚ºãƒ¼ãƒ </b>ï¼šHUD ã®æ•°å€¤æ¬„ã« <b>50ã€œ300%</b> ã‚’å…¥åŠ› â†’ Enterï¼<b>é©ç”¨</b>ã§ç¢ºå®šã€‚PC ã¯ <b>Ctrl/âŒ˜+ãƒ›ã‚¤ãƒ¼ãƒ«</b> ã§ã‚‚æ‹¡å¤§ç¸®å°ã€‚</li>
                <li><b>ç”»åƒã®èª­ã¿è¾¼ã¿</b>ï¼š<code>map.png</code> ã‚’åŒéšå±¤ã«ç½®ãã¨è‡ªå‹•è¡¨ç¤ºã€‚åˆ¥ç”»åƒã¯å³ä¸Šã® <b>ğŸ“‚ ç”»åƒã‚’é–‹ã</b> ã‹ã‚‰ã€‚</li>
                <li><b>å¡—ã‚Šã¤ã¶ã—</b>ï¼šç”»åƒã‚’ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã€‚<b>è¨±å®¹å·®</b>ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§å¢ƒç•Œã®ã«ã˜ã¿ã«å¯¾å¿œã€‚<b>é€£çµã®ã¿</b>ã§éš£æ¥é ˜åŸŸã ã‘å¡—ã‚‹ã€‚</li>
                <li><b>ã‚¹ãƒã‚¤ãƒˆ</b>ï¼š<kbd>I</kbd> ã‚­ãƒ¼ã§åˆ‡æ›¿ â†’ ç”»åƒä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è‰²å–å¾—ï¼ˆè‡ªå‹•ã§å¡—ã‚Šãƒ¢ãƒ¼ãƒ‰ã¸ï¼‰ã€‚</li>
                <li><b>ãƒ‘ãƒ³</b>ï¼šç”»åƒä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ï¼ˆæ‹¡å¤§æ™‚ã‚„ç”»åƒãŒå¤§ãã„æ™‚ï¼‰ã€‚</li>
                <li><b>ä¿å­˜</b>ï¼šå³ä¸Š<b>PNGä¿å­˜</b>ã§æ›¸ãå‡ºã—ã€‚å¡—ã‚Šå±¥æ­´ã¯ <b>localStorage</b> ã«è‡ªå‹•ä¿å­˜ãƒ»å¾©å…ƒï¼ˆç”»åƒã”ã¨ï¼‰ã€‚</li>
                <li><b>ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—</b>ï¼šå³ãƒ‘ãƒãƒ«ã®<b>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</b>ã§å±¥æ­´ã‚’JSONã¨ã—ã¦ä¿å­˜/èª­ã¿è¾¼ã¿ã€‚</li>
              </ul>
            </div>
          </section>

          <footer className="py-5 text-center text-xs text-gray-500">
            ç”»åƒã¯ç«¯æœ«å†…ã§ã®ã¿å‡¦ç†ã•ã‚Œã¾ã™ã€‚å¡—ã‚ŠçŠ¶æ…‹ã¯ localStorage ã«ä¿å­˜ãƒ»å¾©å…ƒã€‚ã‚¹ãƒãƒ›ã¯ãƒ•ãƒ«å¹…è¡¨ç¤ºã€ãƒšãƒ¼ã‚¸ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç„¡åŠ¹ã€ãƒ‘ãƒ³ã®ã¿ã€‚
          </footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
