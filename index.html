<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>クリック塗りつぶしマップ</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html,body { height: 100%; }
    .touch-none { touch-action: none; } /* キャンバスの独自パン用 */
    kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;background:#f5f5f5;border:1px solid #ddd;border-bottom-width:2px;padding:2px 6px;border-radius:6px;font-size:12px;}
    .btn-compact{ padding:6px 10px; border-radius:12px; border:1px solid #e5e7eb; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.04); }
    .icon-label{ display:none; }          /* モバイル: アイコンのみ */
    @media (min-width: 1024px){          /* PC: テキスト表示 */
      .icon-label{ display:inline; }
      .icon-only{ display:none; }
    }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    // 自動読み込み画像
    const DEFAULT_IMAGE = "map.png";
    const getImgFromQuery = () => {
      const p = new URLSearchParams(location.search);
      const v = p.get("img");
      return v && v.trim() ? v.trim() : null;
    };

    // 固定パレット
    const PALETTE_GROUPS = {
      Inochi: ["#e60012", "#0068b7", "#ffffff"],
      Umi:    ["#9b89c6", "#0095b6", "#82cddd", "#8fc31f"],
      Noyama: ["#c5d200", "#fff100", "#0072bc"],
      Hikari: ["#f39800", "#e60012", "#ffd900"],
    };

    // ---- localStorage helpers ----
    const LS = {
      get(key, def=null){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : def; }catch{ return def; } },
      set(key, val){ localStorage.setItem(key, JSON.stringify(val)); },
      del(key){ localStorage.removeItem(key); }
    };

    // 画像ごとのキー（URL/ファイル名 + サイズ）をハッシュ化
    const hashStr = (s) => { let h = 5381; for (let i=0;i<s.length;i++) h = ((h<<5)+h) + s.charCodeAt(i); return (h>>>0).toString(16); };

    // 共通キー名
    const LS_COLOR      = "mf_color";
    const LS_RECENT     = "mf_recent";
    const LS_ACTIONS_NS = "mf_actions:"; // ここに imageKey を連結

    function App() {
      const canvasRef = useRef(null);
      const overlayRef = useRef(null);
      const fileInputRef = useRef(null);
      const viewportRef = useRef(null); // キャンバスを包むスクロール領域（パン対象）

      const [img, setImg] = useState(null);
      const [imageKey, setImageKey] = useState(null);

      // 表示倍率（CSSのみ。内部ピクセルは原寸）
      const [zoom, setZoom] = useState(1);

      // 色
      const [color, setColor] = useState(LS.get(LS_COLOR, "#e60012"));
      const [recentColors, setRecentColors] = useState(LS.get(LS_RECENT, [])); // 先頭が最新

      const [tolerance, setTolerance] = useState(28);
      const [contiguous, setContiguous] = useState(true);
      const [mode, setMode] = useState("fill"); // F/I/Bで切替（UIは出さない）
      const [undoStack, setUndoStack] = useState([]);
      const [redoStack, setRedoStack] = useState([]);
      const [canvasSize, setCanvasSize] = useState({ w: 0, h: 0 });

      // パン用
      const [isPanning, setIsPanning] = useState(false);
      const panStateRef = useRef({ startX:0, startY:0, scrollL:0, scrollT:0, moved:false, pointerId:null });
      const suppressClickRef = useRef(false); // パン後の誤クリック抑制

      // 初期画像ロード
      useEffect(() => {
        const first = getImgFromQuery() || DEFAULT_IMAGE;
        autoLoadImage(first).catch(() => console.warn("自動読み込み用の画像が見つかりません:", first));
      }, []);

      // D&D 取り込み
      useEffect(() => {
        const onDrop = (e) => { e.preventDefault(); const f = e.dataTransfer?.files?.[0]; if (f) loadFile(f); };
        const onDrag = (e) => e.preventDefault();
        window.addEventListener("drop", onDrop);
        window.addEventListener("dragover", onDrag);
        return () => { window.removeEventListener("drop", onDrop); window.removeEventListener("dragover", onDrag); };
      }, []);

      // ショートカット
      useEffect(() => {
        const isEditable = (el) => {
          if (!el) return false;
          const tag = el.tagName?.toLowerCase();
          return tag === "input" || tag === "textarea" || tag === "select" || el.isContentEditable;
        };
        const clampTol = (v) => Math.max(0, Math.min(128, v));
        const onKeyDown = (e) => {
          if (isEditable(document.activeElement)) return;
          const ctrl = e.ctrlKey || e.metaKey;
          const shift = e.shiftKey;
          const key = e.key;

          if (ctrl && key.toLowerCase() === "z" && !shift) { e.preventDefault(); undo(); return; }
          if ((ctrl && key.toLowerCase() === "y") || (ctrl && key.toLowerCase() === "z" && shift)) { e.preventDefault(); redo(); return; }

          if (!ctrl && !shift && key.toLowerCase() === "f") { setMode("fill"); return; }
          if (!ctrl && !shift && key.toLowerCase() === "i") { setMode("eyedropper"); return; }
          if (!ctrl && !shift && key.toLowerCase() === "b") { setMode(m => m==="fill" ? "eyedropper" : "fill"); return; }

          if (!ctrl && !shift && key.toLowerCase() === "s") { e.preventDefault(); savePng(); return; }
          if (!ctrl && !shift && key.toLowerCase() === "o") { e.preventDefault(); handleOpen(); return; }
          if (!ctrl && !shift && key.toLowerCase() === "r") { e.preventDefault(); clearToOriginal(); return; }

          if (!ctrl && !shift && key.toLowerCase() === "g") { setContiguous(v => !v); return; }

          if (key === "[" || key === "-") { setTolerance(v => clampTol(v - 4)); return; }
          if (key === "]" || key === "=" || key === "+") { setTolerance(v => clampTol(v + 4)); return; }
        };
        window.addEventListener("keydown", onKeyDown, { passive: false });
        return () => window.removeEventListener("keydown", onKeyDown);
      }, [undoStack, redoStack]);

      // 色 → 保存＆最近色
      useEffect(() => {
        LS.set(LS_COLOR, color);
        setRecentColors((prev) => {
          const next = [color, ...pre]()
