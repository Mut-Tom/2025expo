<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <!-- ページ全体のピンチズームを無効化 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>クリック塗りつぶしマップ</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html,body { height: 100%; }
    .touch-none { touch-action: none; }
    kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;background:#f5f5f5;border:1px solid #ddd;border-bottom-width:2px;padding:2px 6px;border-radius:6px;font-size:12px;}
    .btn-compact{ padding:6px 10px; border-radius:12px; border:1px solid #e5e7eb; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.04); }
    .icon-label{ display:none; }
    @media (min-width: 1024px){
      .icon-label{ display:inline; }
      .icon-only{ display:none; }
    }
    .zoom-input{ width:72px; text-align:right; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    const DEFAULT_IMAGE = "map.png";

    const PALETTE_GROUPS = {
      Inochi: ["#e60012", "#0068b7", "#ffffff"],
      Umi:    ["#9b89c6", "#0095b6", "#82cddd", "#8fc31f"],
      Noyama: ["#c5d200", "#fff100", "#0072bc"],
      Hikari: ["#f39800", "#e60012", "#ffd900"],
    };

    const LS = {
      get(key, def=null){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : def; }catch{ return def; } },
      set(key, val){ localStorage.setItem(key, JSON.stringify(val)); },
      del(key){ localStorage.removeItem(key); }
    };

    const hashStr = (s) => { let h = 5381; for (let i=0;i<s.length;i++) h = ((h<<5)+h) + s.charCodeAt(i); return (h>>>0).toString(16); };

    const LS_COLOR      = "mf_color";
    const LS_RECENT     = "mf_recent";
    const LS_ACTIONS_NS = "mf_actions:";

    function App() {
      const canvasRef = useRef(null);
      const overlayRef = useRef(null);
      const fileInputRef = useRef(null);
      const viewportRef = useRef(null);

      const [img, setImg] = useState(null);
      const [imageKey, setImageKey] = useState(null);
      const [zoom, setZoom] = useState(1);
      const [zoomInput, setZoomInput] = useState("100");

      const [color, setColor] = useState(LS.get(LS_COLOR, "#e60012"));
      const [recentColors, setRecentColors] = useState(LS.get(LS_RECENT, []));
      const [tolerance, setTolerance] = useState(28);
      const [contiguous, setContiguous] = useState(true);
      const [undoStack, setUndoStack] = useState([]);
      const [redoStack, setRedoStack] = useState([]);
      const [canvasSize, setCanvasSize] = useState({ w: 0, h: 0 });

      const [isPanning, setIsPanning] = useState(false);
      const panStateRef = useRef({ startX:0, startY:0, scrollL:0, scrollT:0, moved:false, pointerId:null });
      const suppressClickRef = useRef(false);

      // ===== ページの二本指ピンチズームを抑止 =====
      useEffect(() => {
        const stopWheelZoom = (e) => { if (e.ctrlKey || e.metaKey) e.preventDefault(); };
        const stopGesture = (e) => { e.preventDefault(); };
        document.addEventListener('wheel', stopWheelZoom, { passive: false });
        document.addEventListener('gesturestart', stopGesture, { passive: false });
        document.addEventListener('gesturechange', stopGesture, { passive: false });
        document.addEventListener('gestureend', stopGesture, { passive: false });
        return () => {
          document.removeEventListener('wheel', stopWheelZoom);
          document.removeEventListener('gesturestart', stopGesture);
          document.removeEventListener('gesturechange', stopGesture);
          document.removeEventListener('gestureend', stopGesture);
        };
      }, []);

      const clampZoom = (z) => Math.min(3, Math.max(0.5, +z.toFixed(3)));
      const updateZoom = (nextZoom) => {
        const nz = clampZoom(nextZoom);
        setZoom(nz);
        applyCanvasCssSize(img);
      };

      // 初期ロード
      useEffect(() => {
        const image = new Image();
        image.onload = () => afterImageLoaded(image, DEFAULT_IMAGE);
        image.src = DEFAULT_IMAGE;
      }, []);

      const getMaxCanvasCssWidth = () => {
        const viewport = Math.min(window.innerWidth, 1536);
        return Math.max(240, viewport - 120);
      };

      const applyCanvasCssSize = (imageOrNull) => {
        const canvas  = canvasRef.current;
        const overlay = overlayRef.current;
        if (!canvas) return;

        const imgW = imageOrNull?.width  ?? canvas.width;
        const imgH = imageOrNull?.height ?? canvas.height;

        const maxCssW = getMaxCanvasCssWidth();
        const baseRatio = Math.min(1, maxCssW / imgW); // 修正済み
        const ratio = baseRatio * zoom;

        const cssW = Math.round(imgW * ratio);
        const cssH = Math.round(imgH * ratio);
        canvas.style.width  = cssW + "px";
        canvas.style.height = cssH + "px";
        if (overlay) {
          overlay.style.width  = cssW + "px";
          overlay.style.height = cssH + "px";
        }
      };

      const afterImageLoaded = (image, srcHint) => {
        setImg(image);
        const canvas  = canvasRef.current;
        const overlay = overlayRef.current;
        canvas.width = image.width;
        canvas.height = image.height;
        if (overlay) { overlay.width = image.width; overlay.height = image.height; }
        setCanvasSize({ w: image.width, h: image.height });
        const ctx = canvas.getContext("2d");
        ctx.drawImage(image,0,0);
        setUndoStack([]); setRedoStack([]);

        const keySeed = (srcHint || image.src) + `@${image.width}x${image.height}`;
        setImageKey(LS_ACTIONS_NS + hashStr(keySeed));
        applyCanvasCssSize(image);
      };

      // ===== ズーム入力欄 =====
      const applyZoomInput = () => {
        let raw = (zoomInput ?? "").toString().trim().replace(/\s+/g,"");
        if (raw.endsWith("%")) raw = raw.slice(0,-1);
        let val = parseInt(raw,10);
        if (isNaN(val)) { setZoomInput(String(Math.round(zoom*100))); return; }
        val = Math.max(50, Math.min(300, val));
        setZoomInput(String(val));
        updateZoom(val/100);
      };
      const onZoomInputKey = (e) => {
        if (e.key==="Enter"){ e.preventDefault(); applyZoomInput(); }
        else if (e.key==="Escape"){ setZoomInput(String(Math.round(zoom*100))); e.currentTarget.blur(); }
      };

      const STEP_FACTOR = 1.5;

      return (
        <div className="min-h-screen w-full">
          <header className="sticky top-0 z-20 border-b bg-white/90 backdrop-blur">
            <div className="mx-auto max-w-screen-2xl px-4 py-2 flex items-center">
              <div className="text-lg font-bold">クリックで塗りつぶせるマップ</div>
            </div>
          </header>

          <main className="mx-auto max-w-screen-2xl p-4">
            <div className="rounded-2xl bg-white border shadow p-3">
              <div ref={viewportRef} className="relative overflow-auto rounded-xl text-center touch-none">
                <div className="relative inline-block">
                  <canvas ref={canvasRef} className="rounded-xl border" />
                  <canvas ref={overlayRef} className="absolute inset-0 pointer-events-none rounded-xl" />
                </div>

                {/* HUD */}
                <div className="sticky bottom-2 left-0 right-0 flex justify-center pointer-events-none">
                  <div className="pointer-events-auto inline-flex items-center gap-2 px-3 py-1.5 rounded-full border bg-white/90 shadow text-sm">
                    <button className="px-2 py-0.5 border rounded" onClick={()=>updateZoom(1)}>100%</button>
                    <button className="px-2 py-0.5 border rounded" onClick={()=>updateZoom(zoom/STEP_FACTOR)}>−</button>
                    <form onSubmit={(e)=>{e.preventDefault();applyZoomInput();}} className="flex items-center gap-1">
                      <span>Zoom</span>
                      <input
                        className="zoom-input px-2 py-0.5 border rounded"
                        value={zoomInput}
                        onChange={(e)=>setZoomInput(e.target.value)}
                        onKeyDown={onZoomInputKey}
                        onBlur={applyZoomInput}
                        inputMode="numeric"
                        placeholder="100"
                      />
                      <span>%</span>
                      <button type="submit" className="px-2 py-0.5 border rounded">適用</button>
                    </form>
                    <button className="px-2 py-0.5 border rounded" onClick={()=>updateZoom(zoom*STEP_FACTOR)}>＋</button>
                    <button className="px-2 py-0.5 border rounded" onClick={()=>updateZoom(1)}>Fit</button>
                  </div>
                </div>
              </div>
            </div>
          </main>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
